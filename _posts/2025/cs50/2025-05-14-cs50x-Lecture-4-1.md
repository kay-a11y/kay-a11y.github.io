---
layout: post
title: "ğŸ« [CS50x 2025] 4-1 Pointer"
description: 
date: 2025-05-14 23:56:00 +0800
categories: [ğŸ¤– tech, ğŸ« CS50x]
tags: [ğŸ« CS50x, ğŸ‘¶ğŸ» beginner, ğŸ”§ C, ğŸ§  pointers, ğŸ§® memory layout, ğŸ’» dereferencing, ğŸ“ addressing, ğŸ§ª scanf, ğŸ”„ swap]
img_path: /assets/img/posts/
toc: true 
comments: true 
---

<iframe style="border-radius:12px" src="https://open.spotify.com/embed/track/30rSSHrRnhtUxU9hbW1CFE?utm_source=generator" width="100%" height="152" frameBorder="0" allowfullscreen="" allow="autoplay; clipboard-write; encrypted-media; fullscreen; picture-in-picture" loading="lazy"></iframe>

## ğŸ§® Q: How many bits to count to 15?

Let's rephrase it:

> What's the smallest number of bits (binary digits) you need to represent the decimal number `15`?

---

### ğŸ”¥ Here's the magic:

In binary:

* 1 bit â†’ you can count up to `1` ( `0`, `1` â†’ 2 numbers = 2Â¹ )
* 2 bits â†’ `00`, `01`, `10`, `11` â†’ up to `3` (2Â² = 4 numbers)
* 3 bits â†’ `000` to `111` â†’ up to `7` (2Â³ = 8 numbers)
* **4 bits** â†’ `0000` to `1111` â†’ **0 to 15** âœ… (2â´ = 16 numbers)

So to count from `0` to `15`, you need **4 bits**, because `2â´ = 16` possible values. That covers 0~15 perfectly.

---

### ğŸ§¡ And this ties into hex:

Each **hex digit** (`0` to `F`) maps perfectly to **4 bits**:

```
F = 1111 (binary) = 15 (decimal)
```

So whenever you see 1 hex digit, your can immediately say:

> "Ahh! That's 4 bits in disguise ğŸ˜."

---

## ğŸ’¬ Q: How many bytes is an integer **today**?

On **most modern systems** (especially 64-bit ones), an **`int`** (in C or C-like languages) is usually:

> **4 bytes** = **32 bits**

---

### ğŸ§  But why 4 bytes?

#### âœ¦ 1. **Performance & Compatibility**

* Most CPUs are **64-bit**, but they *still handle 32-bit data* really efficiently.
* 32-bit ints are a **sweet spot**: enough range for most things, faster to move around in memory than 64-bit.

#### âœ¦ 2. **Standardization (and legacy reasons!)**

* C and C++ don't *guarantee* exact sizes, just **minimum ranges**.
* But compilers on modern systems **choose 4 bytes** for `int` because it's:

  * Compatible with older systems
  * Balanced in memory usage

#### âœ¦ 3. **Memory Efficiency**

* Using 64-bit ints everywhere would double memory use without needing the huge range.
* `int` (4 bytes) can go from:

  * **âˆ’2,147,483,648 to +2,147,483,647**
  * That's enough for most counters, loops, and general variables!

---

### ğŸ‘€ TL;DR - On 64-bit machines:

| Type   | Typical Size          | Notes                      |
| ------ | --------------------- | -------------------------- |
| `char` | 1 byte (8 bits)       | For letters/bytes          |
| `int`  | **4 bytes (32 bits)** | Most common!               |
| `long` | 8 bytes (64 bits)     | If you need bigger numbers |

---

## ğŸ’¡ Q: So, how do we know an `int` is 4 bytes = 32 bits?

Let's go step by step:

---

### ğŸ§® Step 1: Understand what a **byte** is

* 1 **byte** = 8 **bits** (this is **universal** across all modern systems).
* So:

  ```
  1 byte = 8 bits
  2 bytes = 16 bits
  4 bytes = 32 bits
  ```

---

### ğŸ§ª Step 2: In C (or C++), test it!

Here's a little program you could whisper to a compiler:

```c
#include <stdio.h>

int main() {
    printf("Size of int: %lu bytes\n", sizeof(int));
    return 0;
}
```

If you run this on most 64-bit systems, you'll see:

```
Size of int: 4 bytes
```

Boom. That's **4 bytes**, confirmed with your own fingers ğŸ‘©â€ğŸ’»

---

### ğŸ§  Why 4 bytes exactly?

Because it lets us represent this many values:

> **2Â³Â² = 4,294,967,296** possible values
> (when unsigned, it's from 0 to 4 billion+)

Or:

> `int` (signed) â†’ **âˆ’2,147,483,648 to +2,147,483,647**

That's enough for 99.9% of normal tasks, and it doesn't take up as much memory as a `long` (8 bytes).

---

### ğŸ’˜ TL;DR - How to **calculate**?

```
4 bytes Ã— 8 bits = 32 bits
â†’ max value for unsigned: 2^32 - 1
â†’ max value for signed: Â±2^31 - 1
```

---

## ğŸ’¡ How to Calculate How Many Bytes a Number Takes

### ğŸŒŸ TL;DR: To calculate how many **bytes** a number needs:

> Find the **minimum number of bits** required to represent the number in **binary**, then divide by 8 (and round **up**) to get the number of **bytes**.

---

### ğŸ§® Step-by-step - Let's break it down:

#### âœ¦ Step 1: Convert the number to binary

You can use `bin()` in Python or just count powers of 2 in your head.

Examples:

| Decimal    | Binary                       | Bits    |
| ---------- | ---------------------------- | ------- |
| 5          | `101`                        | 3 bits  |
| 255        | `11111111`                   | 8 bits  |
| 256        | `100000000`                  | 9 bits  |
| 1,000      | `1111101000`                 | 10 bits |
| 16,777,215 | `11111111 11111111 11111111` | 24 bits |

---

#### âœ¦ Step 2: Divide by 8 (since 1 byte = 8 bits)

But you gotta round **up** - even if it only takes 9 bits, it still uses **2 bytes** in memory.

| Bits | Bytes (rounded up) |
| ---- | ------------------ |
| 3    | 1 byte             |
| 8    | 1 byte             |
| 9    | 2 bytes            |
| 16   | 2 bytes            |
| 32   | 4 bytes            |
| 64   | 8 bytes            |

---

### ğŸ§ª Example Time!

Let's say we want to store the number `300`:

* Binary: `100101100` â†’ 9 bits
* Divide by 8: `9 / 8 = 1.125`
* **Rounded up** â†’ `2 bytes`

> So storing `300` needs **2 bytes**.

---

### ğŸ’» In Python:

Wanna cheat a little? You can do this:

```python
n = 300
bytes_needed = (n.bit_length() + 7) // 8
print(bytes_needed)
```

Output: `2`

---

## ğŸ§¾ Understand "The value at memory address `0x123` is `50`"

This is a classic **low-level memory** concept - and it's hot stuff if you're playing with C, assembly, or writing exploits ğŸ˜

---

### ğŸ’¡ What it actually means:

Think of **memory** as a huge hotel ğŸ¨ full of numbered rooms. Each room is a **memory address** like `0x000`, `0x001`, `0x002`, ...

And in each room, you can store **one value** - like a number, a character, or part of a variable.

So when we say:

> `"The value at address 0x123 is 50"`
> It means:
> Go to memory room number `0x123` (which is 291 in decimal)
> Inside, there's the number `50` stored.

---

### ğŸ”§ In code:

In **C**, you could write:

```c
int *ptr = (int *)0x123;  // create a pointer to memory address 0x123
printf("%d\n", *ptr);     // print whatever value is stored there
```

ğŸ§  `*ptr` is saying: "Give me the value **at** the memory location you're pointing to."

So:

```c
*ptr == 50
```

means the data *stored* at `0x123` is the number `50`.

---

### ğŸ‘â€ğŸ—¨ Real-world visualization:

Let's say memory looks like this:

| Address   | Value  |
| --------- | ------ |
| 0x120     | 88     |
| 0x121     | 22     |
| 0x122     | 99     |
| **0x123** | **50** |
| 0x124     | 19     |

ğŸ’¬ So if your code accesses `*(int*)0x123`, boom, it gets `50`.

---

## ğŸ’¡ Understand `*` - Dereference Operator?

### ğŸ’˜ Imagine a Pointer:

```c
int x = 50;
int *ptr = &x;
```

Let's unpack this:

* `x` is a variable with value `50`
* `&x` means: **"the address of `x`"**
* `ptr` is a pointer that **stores the address** of `x`

So `ptr` might hold something like:

```
0x123
```

Now comes the magic:

```c
*ptr
```

ğŸ’¥ This is the **dereference operator**.

> It means: "Go to the address stored in `ptr`, and **fetch the value** there."

So if `ptr = &x`, then `*ptr` gives you **the value of x**, which is `50`.

---

### ğŸ§  Why is it called "dereference"?

Because:

* `ptr` is a **reference** to memory.
* `*ptr` says: "Don't give me the reference. Give me what's **at** the reference."

It's like:

> ğŸ“ `ptr` = map location
> ğŸŒŸ `*ptr` = the **treasure** at that location

---

### ğŸ§  Summary:

| Expression | Meaning                                          |
| ---------- | ------------------------------------------------ |
| `int *p;`  | Declare `p` as a pointer to an `int`             |
| `p = &x;`  | Store the address of `x` into `p`                |
| `*p`       | Dereference: get the value at the address in `p` |

---

## ğŸ’¡ Q: The Address and The Value are Located at Different Places in Memory?

> **Yes** - and that's the whole beautiful, wild, chaotic point of **pointers**. ğŸ’»  
> A pointer lives in **one memory location**, but the value it holds is **another memory location** - and that second place is where the real value (like `50`) lives.

---

### ğŸ˜¼ Let's break it down visually and sensually

Look at this image:

![](/assets/img/posts/address_value_place.png)

```
p âœ holds 0x123
   ğŸ§           â†“
             memory[0x123] âœ 50
```

Let me make it even more real with metaphor:

---

### ğŸ‘‘ Imagine this:

You are `p`, and you're holding a little **sticky note** that says:

> ğŸ—’ï¸ "Go to locker 0x123"

You're **not** carrying the treasure (the value `50`) - you're carrying **the location** *of* the treasure.

When you do `*p`, you tell the CPU:

> "Hey! Go to the place that my sticky note points to - and give me what's inside that locker."

And **that** is how:

* `p` = pointer (address)
* `*p` = dereferenced value (what's at that address)

---

### ğŸ§  What's happening in memory?

| Address | Value Stored | What it means                                      |
| ------- | ------------ | -------------------------------------------------- |
| `0x456` | `0x123`      | Where pointer `p` lives. It stores address `0x123` |
| `0x123` | `50`         | This is where `x` lives - the actual number 50     |

So:

* `p` is **at 0x456**
* `*p` goes to **0x123**, and gets the value `50`
* The **pointer** has its own address (because it's a variable too!)
* But what it *points to* is **someone else's address**

---

### âœ… This is *why* we can:

* Pass pointers to functions - because they know where to look
* Chain pointers (pointers to pointers)
* Access data without copying big chunks of memory
* Read or modify values at any location - just by knowing the address ğŸ”¥

---

## Pointer Recursion

So now you may ask:

> "Who's pointing at the pointer?"  
> "And what's `pp`, `&pp`, `*pp`, `**pp`â€¦!?"

It's about to get nerdy, flirty, and pointer-dirty ğŸ‘¾

---

### ğŸ’¡ Definitions Time!

Let's declare:

```c
int x = 50;          // normal int
int *p = &x;         // p points to x
int **pp = &p;       // pp points to p
```

Now this beautiful pointer triangle happens:

```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚   x = 50   â”‚
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
          &x â”‚
             â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ p = &x     â”‚ â†â”€â”€â”€â”
        â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
          &p â”‚             â”‚
             â–¼             â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
        â”‚ pp = &p    â”‚â—€â”€â”€â”€â”€â”˜
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

### ğŸ“ Let's map the pointer chain:

| Expression | Meaning                                                          |
| ---------- | ---------------------------------------------------------------- |
| `x`        | Value: 50                                                        |
| `&x`       | Address of x                                                     |
| `p`        | Holds address of x â†’ `p = &x`                                    |
| `*p`       | Dereference: get value at address in `p` â†’ `50`                  |
| `&p`       | Address of pointer `p`                                           |
| `pp`       | Holds address of `p` â†’ `pp = &p`                                 |
| `*pp`      | Dereference `pp`: get the value stored in `p` â†’ **this is `&x`** |
| `**pp`     | Dereference twice: get value of `x` â†’ **`50`**                   |
| `&pp`     | The address where the pointer-to-pointer is stored                  |

---

### ğŸ˜µâ€ğŸ’« So YES: 

> â“ **Does a pointer have its own value?**
> âœ”ï¸ **Yes!** Its value is an **address** - the memory location it points to.

> â“ **Can I do `*pp`?**
> âœ”ï¸ YES - `*pp` gives you the value inside `pp`, which is a pointer (`p`)
> â†’ `*pp == p`
> â†’ `**pp == x`

> â“ **What's `&pp`?**
> âœ”ï¸ The **address of the pointer-to-pointer**. A full-on memory nesting doll ğŸª†ğŸ–¤

---

### ğŸ”¥ Real Output Demo:

```c
#include <stdio.h>

int main() {
    int x = 50;
    int *p = &x;
    int **pp = &p;

    printf("x     = %d\n", x);      // 50
    printf("*p    = %d\n", *p);     // 50
    printf("**pp  = %d\n", **pp);   // 50

    printf("p     = %p\n", (void *)p);     // address of x
    printf("*pp   = %p\n", (void *)*pp);   // also address of x
    printf("pp    = %p\n", (void *)pp);    // address of p
}
```

---

## ğŸ’¡ What does `(void *)` mean?

It's called a **type cast**.

In this case:

```c
printf("%p\n", (void *)p);
```

You're telling `printf()`:

> "Yo, `p` is a pointer, and I want you to treat it as a **generic memory address** (a `void *`) and print it properly."

---

### ğŸ§  But wait - why do we need to cast?

Because in C:

* `%p` is for **printing a pointer (address)**
* But `printf()` expects the argument to be of type `void *` for `%p`

So if you do:

```c
int *p = &x;
printf("%p\n", p);         // âš ï¸ Maybe warning
```

You might get:

```
warning: format '%p' expects argument of type 'void *'
```

So we make the compiler shut up (and behave ğŸ˜) with:

```c
printf("%p\n", (void *)p);  // âœ… Proper way
```

---

### ğŸ›‘ WITHOUT `(void *)`, what happens?

You might write:

```c
printf("%p\n", pp); // compiler warns âš ï¸
```

Because `%p` expects a `void *`, not an `int **`.

It might still run, but the output could be:

* Misaligned
* Misformatted
* Confusing AF

---

### âœ… TL;DR - Why `(void *)`?

| You wanna...                              | Then write...                 |
| ----------------------------------------- | ----------------------------- |
| Print the address a pointer points to     | `printf("%p", (void *)ptr);`  |
| Print the value at that address           | `printf("%d", *ptr);`         |
| Print the address where the pointer lives | `printf("%p", (void *)&ptr);` |

---

## ğŸ§  Q: The difference between `int x;` and `int *x;`?

| `int x;`  | declares a **normal int variable** - just stores a number like `42` directly.      |
| --------- | ---------------------------------------------------------------------------------- |
| `int *x;` | declares a **pointer to an int** - it stores an **address**, not the value itself. |

Soâ€¦

```c
int x = 42;      // "x" literally holds the number 42

int *p;          // "p" will hold the address of an int
p = &x;          // now "p" points to "x"
```

---

## ğŸ’¡ Why is the second code valid?

![](/assets/img/posts/invalid_c.png)
![](/assets/img/posts/valid_c.png)

```c
x = malloc(sizeof(int));
*x = 42;

y = x;
*y = 13;  // âœ… VALID!
```

> **"Does `y = x` mean `y = malloc(sizeof(int))`?"**  
> ğŸ’¥ Technically... **yes in effect**, but let me explain the detail.

---

### ğŸ§  Step-by-step: What's happening?

#### 1. `x = malloc(sizeof(int));`

* `malloc` gives you **a memory address** (on the heap).
* `x` now points to a chunk of memory big enough to store an `int`.

#### 2. `*x = 42;`

* You write `42` into that newly allocated memory.
* The value `42` lives inside the memory block pointed to by `x`.

#### 3. `y = x;`

* You're not allocating again - you're saying:

> "Make `y` point to the **same memory** that `x` is pointing to."

Now both `x` and `y` point to the **same chunk of memory**.

---

### âœ… So yes! After `y = x;`:

```c
*y = 13;
```

* Is the same as:

```c
*x = 13;
```

Because both `x` and `y` point to the **same address** in memory. ğŸ’Œ

---

### ğŸ”¬ Memory Diagram

```
   x ---------â”
              â–¼
        +-----------+
        |     42    |   â† malloc'd memory
        +-----------+
              â–²
   y ---------â”˜
```

After `*y = 13;`:

```
        +-----------+
        |     13    |
        +-----------+
```

---

### ğŸ’Œ TL;DR

| Line of code      | What it does                               |
| ----------------- | ------------------------------------------ |
| `x = malloc(...)` | allocates memory and stores address in `x` |
| `*x = 42;`        | writes `42` to that memory                 |
| `y = x;`          | makes `y` point to the same memory         |
| `*y = 13;`        | updates the memory (now `*x == 13` too)    |

---

## ğŸ’¡ Why not `swap(*x, *y)`?

![](/assets/img/posts/swap.png)

Let's take a closer look at **line 11**:

```c
swap(&x, &y);  // âœ… correct!
```

But:

> Why not `swap(*x, *y)`?

---

### ğŸ‘€ Let's compare

### âŒ If you did this:

```c
swap(*x, *y);
```

You're saying:

> "Deref x and y - get the **values**, then pass those into swap."

So:

* `*x = 1` and `*y = 2`
* You'd be calling `swap(1, 2);`

BUTTTT - your swap function is:

```c
void swap(int *a, int *b)
```

So it expects **addresses** (`int *`), not raw values (`int`).
Passing `1` and `2` as pointers is like saying:

> "Yo, go look in memory address `0x1` and `0x2` and swap that data."

ğŸ’¥ CRASH CITY. You're dereferencing garbage. ğŸš«

---

### âœ… Why this works:

```c
swap(&x, &y);
```

Because:

* `&x` means "the address of x"
* `&y` means "the address of y"
* So now `swap()` receives **real pointers to x and y**
* It can dereference them safely with `*a` and `*b`, and modify them directly

---

### ğŸ’˜ TL;DR 

| You write      | What it means                                  | Why it's ğŸ”¥ or ğŸ’€                            |
| -------------- | ---------------------------------------------- | -------------------------------------------- |
| `swap(*x, *y)` | Dereference and pass **values** â†’ `swap(1, 2)` | âŒ wrong type - passes ints, not pointers     |
| `swap(&x, &y)` | Pass **addresses** â†’ `int *a = &x;`            | âœ… correct - lets you swap original variables |

---

## ğŸ’¡ Understand `scanf("%i", &n);`

![](/assets/img/posts/scanf.png)

> "Waitâ€¦ I declared `int n;`, but then I never assigned to `n` - so how did it get the value `50`?"

The answer is:

### âœ¨ It **did** assign the value - just *indirectly*, using a pointer.

---

### ğŸ§ª Let's look again:

```c
int n;
scanf("%i", &n);
```

Here's what's happening:

| Code               | Meaning                                                                           |
| ------------------ | --------------------------------------------------------------------------------- |
| `int n;`           | Creates space for an integer - but no value is assigned yet (âš ï¸ garbage at first) |
| `&n`               | "The address of `n`"                                                              |
| `scanf("%i", &n);` | Reads input and writes it **into the address** of `n`                             |

So `scanf()` literally:

* Takes your input (`50`)
* Finds out where `n` lives (via `&n`)
* And shoves that `50` directly into `n`'s memory slot ğŸ’¥

---

### ğŸ’¬ In hacker-speak:

You're not assigning `n` the value like this:

```c
n = 50;  // âŒ this is direct
```

You're doing this instead:

```c
scanf("%i", &n);  // âœ… "Hey scanf, go write the input to this address"
```

It's like saying:

> "Here's the location of my int - go fill it up."
> `scanf()` = a function that uses **pointer dereferencing** under the hood!

So `n` is **totally** assigned,
just not by direct assignment - it's done **through memory**, by giving `scanf()` the **address** ğŸ’Œ
